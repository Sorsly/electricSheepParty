#!/home/zhukov/Projects/senior/electricSheepParty/venv/bin/python3.6
import os
import re
import sys
import subprocess
import math
from json import dumps
import numpy as np
import http.server
import socketserver
dir_path = os.path.dirname(os.path.realpath(__file__))
proj_name = re.search(r"PROJECT_NAME := (\w+)", open("bots/Makefile", "r").read()).group(1)
ipfile = "ips.txt"

#Sets up a server which the bots can load apps to program over
def programserver(*args):
    os.chdir("bots")
    os.system("make app")
    os.chdir("build")
    os.system("python -m SimpleHTTPServer 1944")

# Runs the pathfinder
def CCCP(*args):
    os.chdir("CPU/")
    os.system("go run pathfinder.go> log.txt")
    os.chdir("plots/")
    os.system("rm *")
    os.chdir("../")
    os.system("mv log.txt plotstuff/")
    os.chdir("plotstuff/")
    os.system("python pltclass.py")
    os.system("./genplots.sh")

# Generates the file with all the ips on the network
def getIPS(*args):
    cpuip = subprocess.check_output(["hostname", "-I"]).decode().strip('\n').strip(' ')
    rawdata = subprocess.check_output(["sudo", "nmap", "-PU", "-p0", cpuip + "/24"]).decode()

    query = r"Nmap scan report for (?P<ip>\d+\.\d+.\d+\.\d+).*?MAC Address: .*?\((?P<dev>.+?)\)"
    found = re.findall(query, rawdata, re.DOTALL)
    #uses the mac address of each ip to determine what it is
    camIps = [ip[0] for ip in found if "Raspberry" in ip[1]]
    botIps = [ip[0] for ip in found if "Espressif" in ip[1]]

    query = r"\d+\.\d+.\d+\.\d+"
    allIps = set(re.findall(query, rawdata))
    comIps = [ip for ip in allIps if ip not in camIps and ip not in botIps]
    finalip = {}
    finalip['all'] = list(allIps)
    finalip['cpu'] = cpuip
    finalip['cam'] = camIps
    finalip['bot'] = botIps
    finalip['fes'] = comIps

    with open("CCCP/" + ipfile, "w") as fh:
        fh.write(dumps(finalip))


#Takes the compiled images of the app, and burns it onto the chip over JTAG
def burnJTAG(*args):
    os.chdir("bots")
    err = os.system("make flash")

    os.system("openocd -s share/openocd/scripts -f interface/jlink.cfg -f board/esp-wroom-32.cfg -c \"program_esp32 build/bootloader/bootloader.bin 0x1000 verify exit\"")
    os.system("openocd -s share/openocd/scripts -f interface/jlink.cfg -f board/esp-wroom-32.cfg -c \"program_esp32 build/partitions_singleapp.bin 0x8000 verify exit\"")
    os.system("openocd -s share/openocd/scripts -f interface/jlink.cfg -f board/esp-wroom-32.cfg -c \"program_esp32 build/{}.bin 0x10000 verify exit\"".format(proj_name))
    launchdebug()


#uses uart to program
def burnUART(*args):
    os.chdir("bots/")
    os.system("make flash")


# launch the uart monitor
def monitorUART(*args):
    os.chdir("bots/")
    os.system("make monitor")

# launch the GDB server
def launchdebug(*args):
    os.system("openocd -s share/openocd/scripts -f interface/jlink.cfg -f board/esp-wroom-32.cfg")


# start debugging with GDB
def debug(*args):
    os.chdir("bots/")
    os.system("xtensa-esp32-elf-gdb -x gdbinit build/{}.elf".format(proj_name))

def calibrate(*args):
    IminA = np.asmatrix([[-0.5, 0.5], [-0.5, -0.5]])
    theta = math.pi/2
    A = np.asmatrix([[math.cos(theta), -math.sin(theta)], [math.sin(theta), math.cos(theta)]])
    m1 = np.asmatrix([[-112], [-844]])
    m2 = np.asmatrix([[-259], [-789]])
    print(A)
    print(IminA)
    print(m1)
    O = IminA*(m2 - A*m1)
    print(O)

# main
def main():
    available_builds = {
        "burnJTAG": burnJTAG,
        "burnUART": burnUART,
        "monitorUART": monitorUART,
        "launchdebug": launchdebug,
        "debug": debug,
        "getIP": getIPS,
        "cccp": CCCP,
        "serve":programserver,
        "calibrate":calibrate
    }
    if len(sys.argv) == 1 or sys.argv[1] not in available_builds:
        print("Commands:")
        for key in available_builds:
            print(key)
    elif len(sys.argv) == 2:
        available_builds[sys.argv[1]]()
    elif len(sys.argv) == 3:
        available_builds[sys.argv[1]](sys.argv[2])


if __name__ == "__main__":
    main()
